// Code generated by Gojay. DO NOT EDIT.

package common

import (
	"github.com/francoispqt/gojay"
	"sync"
)

func init() {
	BinaSymbolInfoPool = &sync.Pool{
		New: func() interface{} {
			return new(BinaSymbolInfo)
		},
	}
	ExchangeInfoPool = &sync.Pool{
		New: func() interface{} {
			return new(ExchangeInfo)
		},
	}
	FiltersPool = &sync.Pool{
		New: func() interface{} {
			return new(Filters)
		},
	}
	LotSizeFilterPool = &sync.Pool{
		New: func() interface{} {
			return new(LotSizeFilter)
		},
	}
	PriceFilterPool = &sync.Pool{
		New: func() interface{} {
			return new(PriceFilter)
		},
	}
	RateLimitPool = &sync.Pool{
		New: func() interface{} {
			return new(RateLimit)
		},
	}
	SymbolIDPool = &sync.Pool{
		New: func() interface{} {
			return new(SymbolID)
		},
	}
}

var BinaSymbolInfoPool *sync.Pool
var ExchangeInfoPool *sync.Pool
var FiltersPool *sync.Pool
var LotSizeFilterPool *sync.Pool
var PriceFilterPool *sync.Pool
var RateLimitPool *sync.Pool
var SymbolIDPool *sync.Pool

type BinaSymbolInfos []BinaSymbolInfo

func (s *BinaSymbolInfos) UnmarshalJSONArray(dec *gojay.Decoder) error {
	var value = BinaSymbolInfo{}
	if err := dec.Object(&value); err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

func (s BinaSymbolInfos) MarshalJSONArray(enc *gojay.Encoder) {
	for i := range s {
		enc.Object(&s[i])
	}
}

func (s BinaSymbolInfos) IsNil() bool {
	return len(s) == 0
}

type Filterss []Filters

func (s *Filterss) UnmarshalJSONArray(dec *gojay.Decoder) error {
	var value = Filters{}
	if err := dec.Object(&value); err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

func (s Filterss) MarshalJSONArray(enc *gojay.Encoder) {
	for i := range s {
		enc.Object(&s[i])
	}
}

func (s Filterss) IsNil() bool {
	return len(s) == 0
}

type RateLimits []RateLimit

func (s *RateLimits) UnmarshalJSONArray(dec *gojay.Decoder) error {
	var value = RateLimit{}
	if err := dec.Object(&value); err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

func (s RateLimits) MarshalJSONArray(enc *gojay.Encoder) {
	for i := range s {
		enc.Object(&s[i])
	}
}

func (s RateLimits) IsNil() bool {
	return len(s) == 0
}

type Strings []string

// UnmarshalJSONArray decodes JSON array elements into slice
func (a *Strings) UnmarshalJSONArray(dec *gojay.Decoder) error {
	var value string
	if err := dec.String(&value); err != nil {
		return err
	}
	*a = append(*a, value)
	return nil
}

// MarshalJSONArray encodes arrays into JSON
func (a Strings) MarshalJSONArray(enc *gojay.Encoder) {
	for _, item := range a {
		enc.String(item)
	}
}

// IsNil checks if array is nil
func (a Strings) IsNil() bool {
	return len(a) == 0
}

// MarshalJSONObject implements MarshalerJSONObject
func (i *BinaSymbolInfo) MarshalJSONObject(enc *gojay.Encoder) {
	enc.ObjectKey("symbol", &i.Symbol)
	enc.StringKey("status", i.Status)
	enc.ObjectKey("baseAsset", &i.BaseAsset)
	enc.IntKey("baseAssetPrecision", i.BaseAssetPrecision)
	enc.ObjectKey("quoteAsset", &i.QuoteAsset)
	enc.IntKey("quotePrecision", i.QuotePrecision)
	enc.IntKey("quoteAssetPrecision", i.QuoteAssetPrecision)
	enc.Int32Key("baseCommissionPrecision", i.BaseCommissionPrecision)
	enc.Int32Key("quoteCommissionPrecision", i.QuoteCommissionPrecision)
	var orderTypesSlice = Strings(i.OrderTypes)
	enc.ArrayKey("orderTypes", orderTypesSlice)
	enc.BoolKey("icebergAllowed", i.IcebergAllowed)
	enc.BoolKey("ocoAllowed", i.OcoAllowed)
	enc.BoolKey("quoteOrderQtyMarketAllowed", i.QuoteOrderQtyMarketAllowed)
	enc.BoolKey("isSpotTradingAllowed", i.IsSpotTradingAllowed)
	enc.BoolKey("isMarginTradingAllowed", i.IsMarginTradingAllowed)
	var filtersSlice = Filterss(i.Filters)
	enc.ArrayKey("filters", filtersSlice)
	var permissionsSlice = Strings(i.Permissions)
	enc.ArrayKey("permissions", permissionsSlice)
}

// IsNil checks if instance is nil
func (i *BinaSymbolInfo) IsNil() bool {
	return i == nil
}

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (i *BinaSymbolInfo) UnmarshalJSONObject(dec *gojay.Decoder, key string) error {

	switch key {
	case "symbol":
		err := dec.Object(&i.Symbol)

		return err

	case "status":
		return dec.String(&i.Status)

	case "baseAsset":
		err := dec.Object(&i.BaseAsset)

		return err

	case "baseAssetPrecision":
		return dec.Int(&i.BaseAssetPrecision)

	case "quoteAsset":
		err := dec.Object(&i.QuoteAsset)

		return err

	case "quotePrecision":
		return dec.Int(&i.QuotePrecision)

	case "quoteAssetPrecision":
		return dec.Int(&i.QuoteAssetPrecision)

	case "baseCommissionPrecision":
		return dec.Int32(&i.BaseCommissionPrecision)

	case "quoteCommissionPrecision":
		return dec.Int32(&i.QuoteCommissionPrecision)

	case "orderTypes":
		var aSlice = Strings{}
		err := dec.Array(&aSlice)
		if err == nil && len(aSlice) > 0 {
			i.OrderTypes = []string(aSlice)
		}
		return err

	case "icebergAllowed":
		return dec.Bool(&i.IcebergAllowed)

	case "ocoAllowed":
		return dec.Bool(&i.OcoAllowed)

	case "quoteOrderQtyMarketAllowed":
		return dec.Bool(&i.QuoteOrderQtyMarketAllowed)

	case "isSpotTradingAllowed":
		return dec.Bool(&i.IsSpotTradingAllowed)

	case "isMarginTradingAllowed":
		return dec.Bool(&i.IsMarginTradingAllowed)

	case "filters":
		var aSlice = Filterss{}
		err := dec.Array(&aSlice)
		if err == nil && len(aSlice) > 0 {
			i.Filters = []Filters(aSlice)
		}
		return err

	case "permissions":
		var aSlice = Strings{}
		err := dec.Array(&aSlice)
		if err == nil && len(aSlice) > 0 {
			i.Permissions = []string(aSlice)
		}
		return err

	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (i *BinaSymbolInfo) NKeys() int { return 17 }

// Reset reset fields
func (i *BinaSymbolInfo) Reset() {
	i.Status = ""
	i.BaseAssetPrecision = 0
	i.QuotePrecision = 0
	i.QuoteAssetPrecision = 0
	i.BaseCommissionPrecision = 0
	i.QuoteCommissionPrecision = 0
	i.OrderTypes = nil
	i.IcebergAllowed = false
	i.OcoAllowed = false
	i.QuoteOrderQtyMarketAllowed = false
	i.IsSpotTradingAllowed = false
	i.IsMarginTradingAllowed = false
	for idx := range i.Filters {
		i.Filters[idx].Reset()
		FiltersPool.Put(&i.Filters[idx])
	}
	i.Filters = nil
	i.Permissions = nil
}

// MarshalJSONObject implements MarshalerJSONObject
func (i *ExchangeInfo) MarshalJSONObject(enc *gojay.Encoder) {
	enc.StringKey("timezone", i.Timezone)
	enc.Int64Key("serverTime", i.ServerTime)
	var rateLimitsSlice = RateLimits(i.RateLimits)
	enc.ArrayKey("rateLimits", rateLimitsSlice)
	var symbolsSlice = BinaSymbolInfos(i.Symbols)
	enc.ArrayKey("symbols", symbolsSlice)
}

// IsNil checks if instance is nil
func (i *ExchangeInfo) IsNil() bool {
	return i == nil
}

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (i *ExchangeInfo) UnmarshalJSONObject(dec *gojay.Decoder, key string) error {

	switch key {
	case "timezone":
		return dec.String(&i.Timezone)

	case "serverTime":
		return dec.Int64(&i.ServerTime)

	case "rateLimits":
		var aSlice = RateLimits{}
		err := dec.Array(&aSlice)
		if err == nil && len(aSlice) > 0 {
			i.RateLimits = []RateLimit(aSlice)
		}
		return err

	case "symbols":
		var aSlice = BinaSymbolInfos{}
		err := dec.Array(&aSlice)
		if err == nil && len(aSlice) > 0 {
			i.Symbols = []BinaSymbolInfo(aSlice)
		}
		return err

	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (i *ExchangeInfo) NKeys() int { return 4 }

// Reset reset fields
func (i *ExchangeInfo) Reset() {
	i.Timezone = ""
	i.ServerTime = 0
	for idx := range i.RateLimits {
		i.RateLimits[idx].Reset()
		RateLimitPool.Put(&i.RateLimits[idx])
	}
	i.RateLimits = nil
	for idx := range i.Symbols {
		i.Symbols[idx].Reset()
		BinaSymbolInfoPool.Put(&i.Symbols[idx])
	}
	i.Symbols = nil
}

// MarshalJSONObject implements MarshalerJSONObject
func (f *Filters) MarshalJSONObject(enc *gojay.Encoder) {
	enc.StringKeyOmitEmpty("maxQty", f.MaxQuantity)
	enc.StringKeyOmitEmpty("minQty", f.MinQuantity)
	enc.StringKeyOmitEmpty("stepSize", f.StepSize)
	enc.StringKeyOmitEmpty("maxPrice", f.MaxPrice)
	enc.StringKeyOmitEmpty("minPrice", f.MinPrice)
	enc.StringKeyOmitEmpty("tickSize", f.TickSize)
	enc.StringKeyOmitEmpty("filterType", f.FilterType)
}

// IsNil checks if instance is nil
func (f *Filters) IsNil() bool {
	return f == nil
}

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (f *Filters) UnmarshalJSONObject(dec *gojay.Decoder, key string) error {

	switch key {
	case "maxQty":
		return dec.String(&f.MaxQuantity)

	case "minQty":
		return dec.String(&f.MinQuantity)

	case "stepSize":
		return dec.String(&f.StepSize)

	case "maxPrice":
		return dec.String(&f.MaxPrice)

	case "minPrice":
		return dec.String(&f.MinPrice)

	case "tickSize":
		return dec.String(&f.TickSize)

	case "filterType":
		return dec.String(&f.FilterType)

	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (f *Filters) NKeys() int { return 7 }

// Reset reset fields
func (f *Filters) Reset() {
	f.FilterType = ""
}

// MarshalJSONObject implements MarshalerJSONObject
func (f *LotSizeFilter) MarshalJSONObject(enc *gojay.Encoder) {
	enc.StringKeyOmitEmpty("maxQty", f.MaxQuantity)
	enc.StringKeyOmitEmpty("minQty", f.MinQuantity)
	enc.StringKeyOmitEmpty("stepSize", f.StepSize)
}

// IsNil checks if instance is nil
func (f *LotSizeFilter) IsNil() bool {
	return f == nil
}

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (f *LotSizeFilter) UnmarshalJSONObject(dec *gojay.Decoder, key string) error {

	switch key {
	case "maxQty":
		return dec.String(&f.MaxQuantity)

	case "minQty":
		return dec.String(&f.MinQuantity)

	case "stepSize":
		return dec.String(&f.StepSize)

	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (f *LotSizeFilter) NKeys() int { return 3 }

// Reset reset fields
func (f *LotSizeFilter) Reset() {
	f.MaxQuantity = ""
	f.MinQuantity = ""
	f.StepSize = ""
}

// MarshalJSONObject implements MarshalerJSONObject
func (f *PriceFilter) MarshalJSONObject(enc *gojay.Encoder) {
	enc.StringKeyOmitEmpty("maxPrice", f.MaxPrice)
	enc.StringKeyOmitEmpty("minPrice", f.MinPrice)
	enc.StringKeyOmitEmpty("tickSize", f.TickSize)
}

// IsNil checks if instance is nil
func (f *PriceFilter) IsNil() bool {
	return f == nil
}

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (f *PriceFilter) UnmarshalJSONObject(dec *gojay.Decoder, key string) error {

	switch key {
	case "maxPrice":
		return dec.String(&f.MaxPrice)

	case "minPrice":
		return dec.String(&f.MinPrice)

	case "tickSize":
		return dec.String(&f.TickSize)

	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (f *PriceFilter) NKeys() int { return 3 }

// Reset reset fields
func (f *PriceFilter) Reset() {
	f.MaxPrice = ""
	f.MinPrice = ""
	f.TickSize = ""
}

// MarshalJSONObject implements MarshalerJSONObject
func (l *RateLimit) MarshalJSONObject(enc *gojay.Encoder) {
	enc.StringKey("rateLimitType", l.RateLimitType)
	enc.StringKey("interval", l.Interval)
	enc.Int64Key("intervalNum", l.IntervalNum)
	enc.Int64Key("limit", l.Limit)
}

// IsNil checks if instance is nil
func (l *RateLimit) IsNil() bool {
	return l == nil
}

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (l *RateLimit) UnmarshalJSONObject(dec *gojay.Decoder, key string) error {

	switch key {
	case "rateLimitType":
		return dec.String(&l.RateLimitType)

	case "interval":
		return dec.String(&l.Interval)

	case "intervalNum":
		return dec.Int64(&l.IntervalNum)

	case "limit":
		return dec.Int64(&l.Limit)

	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (l *RateLimit) NKeys() int { return 4 }

// Reset reset fields
func (l *RateLimit) Reset() {
	l.RateLimitType = ""
	l.Interval = ""
	l.IntervalNum = 0
	l.Limit = 0
}

// MarshalJSONObject implements MarshalerJSONObject
func (d *SymbolID) MarshalJSONObject(enc *gojay.Encoder) {

}

// IsNil checks if instance is nil
func (d *SymbolID) IsNil() bool {
	return d == nil
}

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (d *SymbolID) UnmarshalJSONObject(dec *gojay.Decoder, key string) error {

	switch key {

	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (d *SymbolID) NKeys() int { return 0 }

// Reset reset fields
func (d *SymbolID) Reset() {

}
